#include "ExcelTypeLib.h"
#include "Connect.h"
#include <xlOil/ExcelRange.h>
#include <xlOil/Register.h>
#include <xlOilHelpers/Environment.h>
#include <xloil/Interface.h>
#include <vector>
#include <memory>

using std::vector;
using std::shared_ptr;
using std::wstring;

namespace xloil
{
  bool checkRegistryKeys()
  {
    auto excelVersion = Core::theExcelVersion();
    auto regKey = fmt::format(L"Software\\Microsoft\\Office\\{0}.0\\Excel\\Security\\AccessVBOM", excelVersion);
    DWORD currentUser = 666, localMachine = 666;
    getWindowsRegistryValue(L"HKCU", regKey, currentUser);
    getWindowsRegistryValue(L"HKLM", regKey, localMachine);
    if (currentUser == 0 || localMachine == 0)
      XLO_THROW("Allow access to VBA Object Model in "
        "File > Options > Trust Center > Trust Center Settings > Macro Settings");
    return true;
  }

  void writeLocalFunctionsToVBA(
    const wchar_t* workbookName, 
    const vector<shared_ptr<const FuncInfo>>& registeredFuncs,
    const vector<wstring> coreRedirects)
  {
    try
    {
      constexpr char* ourModuleName = "xlOil_AutoGenerated";

      static bool registryChecked = checkRegistryKeys();

      auto workbook = excelApp().Workbooks->GetItem(_variant_t(workbookName));

      auto vbProj = workbook->VBProject;

      struct _VBComponent* vbFound = 0;
      vbProj->VBComponents->raw_Item(_variant_t(ourModuleName), &vbFound);
      _VBComponentPtr vbMod;
      if (!vbFound)
      {
        vbMod = vbProj->VBComponents->Add(vbext_ct_StdModule);
        vbMod->PutName(ourModuleName);
      }
      else
      {
        vbMod = vbProj->VBComponents->Item(ourModuleName);
        vbMod->CodeModule->DeleteLines(1, vbMod->CodeModule->CountOfLines);
      }
      auto mod = vbMod->CodeModule;
      auto line = 1;
      for (size_t i = 0; i < registeredFuncs.size(); ++i)
      {
        // We declare all args as optional variant and let the called 
        // function handle things.
        wstring args, optionalArgs;
        for (size_t j = 0; j < registeredFuncs[i]->numArgs(); ++j)
        {
          args += L", x" + std::to_wstring(j);
          optionalArgs += L"Optional x" + std::to_wstring(j) + L",";
        }
        // Drop final comma
        if (!optionalArgs.empty()) optionalArgs.pop_back();

        // We write:
        // Public Function name(Optional arg0, Optional arg1,...)
        // name = Application.Run("xloil_local_N", workbook, name, arg0, arg1, ...)
        // End Function
        auto name = registeredFuncs[i]->name;
        mod->InsertLines(line++, fmt::format(L"Public Function {0}({1})", name, optionalArgs).c_str());
        mod->InsertLines(line++, fmt::format(L"{0} = Application.Run(\"{1}\", \"{2}\", \"{3}\" {4})",
          name, coreRedirects[i], workbookName, name, args).c_str());
        mod->InsertLines(line++, "End Function");
      }
    }
    catch (_com_error& error)
    {
      XLO_THROW(L"COM Error {0:#x}: {1}", (size_t)error.Error(), error.ErrorMessage());
    }
  }
}